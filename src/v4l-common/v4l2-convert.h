"// Texture IDs\n"
"#if PIXFMT == V4L2_PIX_FMT_SBGGR8 || PIXFMT == V4L2_PIX_FMT_SGBRG8 ||     PIXFMT == V4L2_PIX_FMT_SGRBG8 || PIXFMT == V4L2_PIX_FMT_SRGGB8 ||     PIXFMT == V4L2_PIX_FMT_SBGGR10 || PIXFMT == V4L2_PIX_FMT_SGBRG10 ||     PIXFMT == V4L2_PIX_FMT_SGRBG10 || PIXFMT == V4L2_PIX_FMT_SRGGB10 ||     PIXFMT == V4L2_PIX_FMT_SBGGR12 || PIXFMT == V4L2_PIX_FMT_SGBRG12 ||     PIXFMT == V4L2_PIX_FMT_SGRBG12 || PIXFMT == V4L2_PIX_FMT_SRGGB12 ||     PIXFMT == V4L2_PIX_FMT_SBGGR16 || PIXFMT == V4L2_PIX_FMT_SGBRG16 ||     PIXFMT == V4L2_PIX_FMT_SGRBG16 || PIXFMT == V4L2_PIX_FMT_SRGGB16 ||     PIXFMT == V4L2_PIX_FMT_GREY || PIXFMT == V4L2_PIX_FMT_Y16 ||     PIXFMT == V4L2_PIX_FMT_Y16_BE || PIXFMT == V4L2_PIX_FMT_Z16 ||     PIXFMT == V4L2_PIX_FMT_Y10 || PIXFMT == V4L2_PIX_FMT_Y12\n"
"uniform highp usampler2D tex;\n"
"#else\n"
"uniform sampler2D tex;\n"
"#endif\n"
"uniform sampler2D ytex;\n"
"uniform sampler2D uvtex;\n"
"uniform sampler2D utex;\n"
"uniform sampler2D vtex;\n"
"\n"
"in vec2 vs_TexCoord;\n"
"\n"
"out vec4 fs_FragColor;\n"
"\n"
"// YUV (aka Y'CbCr) to R'G'B' matrices\n"
"\n"
"const mat3 yuv2rgb = mat3(\n"
"#if YCBCRENC == V4L2_YCBCR_ENC_SMPTE240M\n"
"	// Old obsolete HDTV standard. Replaced by REC 709.\n"
"	// SMPTE 240M has its own luma coefficients\n"
"	1.0,     1.0,     1.0,\n"
"	0.0,    -0.2253,  1.8270,\n"
"	1.5756, -0.4768,  0.0\n"
"#elif YCBCRENC == V4L2_YCBCR_ENC_BT2020\n"
"	// BT.2020 luma coefficients\n"
"	1.0,     1.0,     1.0,\n"
"	0.0,    -0.1646,  1.8814,\n"
"	1.4719, -0.5703,  0.0\n"
"#elif YCBCRENC == V4L2_YCBCR_ENC_601 || YCBCRENC == V4L2_YCBCR_ENC_XV601\n"
"	// These colorspaces all use the BT.601 luma coefficients\n"
"	1.0,    1.0,    1.0,\n"
"	0.0,   -0.344,  1.773,\n"
"	1.403, -0.714,  0.0\n"
"#else\n"
"	// The HDTV colorspaces all use REC 709 luma coefficients\n"
"	1.0,     1.0,     1.0,\n"
"	0.0,    -0.1870,  1.8556,\n"
"	1.5701, -0.4664,  0.0\n"
"#endif\n"
");\n"
"\n"
"// Various colorspace conversion matrices that transfer the source chromaticities\n"
"// to the sRGB/Rec.709 chromaticities\n"
"\n"
"const mat3 colconv = mat3(\n"
"#if COLSP == V4L2_COLORSPACE_SMPTE170M || COLSP == V4L2_COLORSPACE_SMPTE240M\n"
"	// Current SDTV standard, although slowly being replaced by REC 709.\n"
"	// Uses the SMPTE 170M aka SMPTE-C aka SMPTE RP 145 conversion matrix.\n"
"	0.939536,  0.017743, -0.001591,\n"
"	0.050215,  0.965758, -0.004356,\n"
"	0.001789,  0.016243,  1.005951\n"
"#elif COLSP == V4L2_COLORSPACE_470_SYSTEM_M\n"
"	// Old obsolete NTSC standard. Replaced by REC 709.\n"
"	// Uses the NTSC 1953 conversion matrix and the Bradford method to\n"
"	// compensate for the different whitepoints.\n"
"	 1.4858417, -0.0251179, -0.0272254,\n"
"	-0.4033361,  0.9541568, -0.0440815,\n"
"	-0.0825056,  0.0709611,  1.0713068\n"
"#elif COLSP == V4L2_COLORSPACE_470_SYSTEM_BG\n"
"	// Old obsolete PAL/SECAM standard. Replaced by REC 709.\n"
"	// Uses the EBU Tech. 3213 conversion matrix.\n"
"	 1.0440, 0,  0,\n"
"	-0.0440, 1, -0.0119,\n"
"	 0,      0,  1.0119\n"
"#elif COLSP == V4L2_COLORSPACE_OPRGB\n"
"	 1.3982832, 0,  0,\n"
"	-0.3982831, 1, -0.0429383,\n"
"	 0,         0,  1.0429383\n"
"#elif COLSP == V4L2_COLORSPACE_DCI_P3\n"
"	// Uses the Bradford method to compensate for the different whitepoints.\n"
"	 1.1574000, -0.0415052, -0.0180562,\n"
"	-0.1548597,  1.0455684, -0.0785993,\n"
"	-0.0025403, -0.0040633,  1.0966555\n"
"#elif COLSP == V4L2_COLORSPACE_BT2020\n"
"	 1.6603627, -0.1245635, -0.0181566,\n"
"	-0.5875400,  1.1329114, -0.1006017,\n"
"	-0.0728227, -0.0083478,  1.1187583\n"
"#else\n"
"	// Identity matrix\n"
"	1.0\n"
"#endif\n"
");\n"
"\n"
"void main()\n"
"{\n"
"	const float texl_w = 1.0 / tex_w;\n"
"	const float texl_h = 1.0 / tex_h;\n"
"	float alpha = 0.0;\n"
"	vec2 xy = vs_TexCoord;\n"
"	float xcoord = floor(xy.x * tex_w);\n"
"	float ycoord = floor(xy.y * tex_h);\n"
"	bool xeven = mod(xcoord, 2.0) == 0.0;\n"
"	bool yeven = mod(ycoord, 2.0) == 0.0;\n"
"	vec3 yuv;\n"
"	vec3 rgb;\n"
"\n"
"#if FIELD == V4L2_FIELD_SEQ_TB\n"
"	xy.y = (mod(ycoord, 2.0) == 0.0) ? xy.y / 2.0 : xy.y / 2.0 + 0.5;\n"
"#elif FIELD == V4L2_FIELD_SEQ_BT\n"
"	xy.y = (mod(ycoord, 2.0) == 0.0) ? xy.y / 2.0 + 0.5 : xy.y / 2.0;\n"
"#endif\n"
"\n"
"#if IS_RGB\n"
"\n"
"// Bayer pixel formats\n"
"#if PIXFMT == V4L2_PIX_FMT_SBGGR8 || PIXFMT == V4L2_PIX_FMT_SBGGR10 || PIXFMT == V4L2_PIX_FMT_SBGGR12 || PIXFMT == V4L2_PIX_FMT_SBGGR16\n"
"	uvec4 urgb;\n"
"	vec2 cell = vec2(xeven ? xy.x : xy.x - texl_w, yeven ? xy.y : xy.y - texl_h);\n"
"	urgb.r = texture(tex, vec2(cell.x + texl_w, cell.y + texl_h)).r;\n"
"	urgb.g = texture(tex, vec2((cell.y == xy.y) ? cell.x + texl_w : cell.x, xy.y)).r;\n"
"	urgb.b = texture(tex, cell).r;\n"
"#elif PIXFMT == V4L2_PIX_FMT_SGBRG8 || PIXFMT == V4L2_PIX_FMT_SGBRG10 || PIXFMT == V4L2_PIX_FMT_SGBRG12 || PIXFMT == V4L2_PIX_FMT_SGBRG16\n"
"	uvec4 urgb;\n"
"	vec2 cell = vec2(xeven ? xy.x : xy.x - texl_w, yeven ? xy.y : xy.y - texl_h);\n"
"	urgb.r = texture(tex, vec2(cell.x, cell.y + texl_h)).r;\n"
"	urgb.g = texture(tex, vec2((cell.y == xy.y) ? cell.x : cell.x + texl_w, xy.y)).r;\n"
"	urgb.b = texture(tex, vec2(cell.x + texl_w, cell.y)).r;\n"
"#elif PIXFMT == V4L2_PIX_FMT_SGRBG8 || PIXFMT == V4L2_PIX_FMT_SGRBG10 || PIXFMT == V4L2_PIX_FMT_SGRBG12 || PIXFMT == V4L2_PIX_FMT_SGRBG16\n"
"	uvec4 urgb;\n"
"	vec2 cell = vec2(xeven ? xy.x : xy.x - texl_w, yeven ? xy.y : xy.y - texl_h);\n"
"	urgb.r = texture(tex, vec2(cell.x + texl_w, cell.y)).r;\n"
"	urgb.g = texture(tex, vec2((cell.y == xy.y) ? cell.x : cell.x + texl_w, xy.y)).r;\n"
"	urgb.b = texture(tex, vec2(cell.x, cell.y + texl_h)).r;\n"
"#elif PIXFMT == V4L2_PIX_FMT_SRGGB8 || PIXFMT == V4L2_PIX_FMT_SRGGB10 || PIXFMT == V4L2_PIX_FMT_SRGGB12 || PIXFMT == V4L2_PIX_FMT_SRGGB16\n"
"	uvec4 urgb;\n"
"	vec2 cell = vec2(xeven ? xy.x : xy.x - texl_w, yeven ? xy.y : xy.y - texl_h);\n"
"	urgb.b = texture(tex, vec2(cell.x + texl_w, cell.y + texl_h)).r;\n"
"	urgb.g = texture(tex, vec2((cell.y == xy.y) ? cell.x + texl_w : cell.x, xy.y)).r;\n"
"	urgb.r = texture(tex, cell).r;\n"
"#elif PIXFMT == V4L2_PIX_FMT_RGB32 || PIXFMT == V4L2_PIX_FMT_XRGB32 || PIXFMT == V4L2_PIX_FMT_ARGB32 ||       PIXFMT == V4L2_PIX_FMT_RGB444 || PIXFMT == V4L2_PIX_FMT_XRGB444 || PIXFMT == V4L2_PIX_FMT_ARGB444\n"
"	vec4 cell = texture(tex, xy);\n"
"#if V4L2_PIX_FMT_ARGB444 || PIXFMT == V4L2_PIX_FMT_ARGB32\n"
"	alpha = cell.r;\n"
"#endif\n"
"	rgb.rgb = cell.gba;\n"
"#elif PIXFMT == V4L2_PIX_FMT_BGR32 || PIXFMT == V4L2_PIX_FMT_XBGR32 || PIXFMT == V4L2_PIX_FMT_ABGR32 ||       PIXFMT == V4L2_PIX_FMT_BGRX444 || PIXFMT == V4L2_PIX_FMT_BGRA444 ||       PIXFMT == V4L2_PIX_FMT_XBGR555 || PIXFMT == V4L2_PIX_FMT_ABGR555 ||       PIXFMT == V4L2_PIX_FMT_RGBX555 || PIXFMT == V4L2_PIX_FMT_RGBA555\n"
"	vec4 cell = texture(tex, xy);\n"
"#if PIXFMT == V4L2_PIX_FMT_ABGR32 || PIXFMT == V4L2_PIX_FMT_BGRA444 || PIXFMT == V4L2_PIX_FMT_RGBA555 || PIXFMT == V4L2_PIX_FMT_ABGR555\n"
"	alpha = cell.a;\n"
"#endif\n"
"	rgb.rgb = cell.bgr;\n"
"#elif PIXFMT == V4L2_PIX_FMT_RGBX32 || PIXFMT == V4L2_PIX_FMT_RGBA32 ||       PIXFMT == V4L2_PIX_FMT_RGBX444 || PIXFMT == V4L2_PIX_FMT_RGBA444 ||       PIXFMT == V4L2_PIX_FMT_RGB555 || PIXFMT == V4L2_PIX_FMT_XRGB555 || PIXFMT == V4L2_PIX_FMT_ARGB555 ||       PIXFMT == V4L2_PIX_FMT_BGRX555 || PIXFMT == V4L2_PIX_FMT_BGRA555\n"
"	vec4 cell = texture(tex, xy);\n"
"#if PIXFMT == V4L2_PIX_FMT_RGBA32 || PIXFMT == V4L2_PIX_FMT_RGBA444 || PIXFMT == V4L2_PIX_FMT_ARGB555 || PIXFMT == V4L2_PIX_FMT_BGRA555\n"
"	alpha = cell.a;\n"
"#endif\n"
"	rgb.rgb = cell.rgb;\n"
"#elif PIXFMT == V4L2_PIX_FMT_BGRX32 || PIXFMT == V4L2_PIX_FMT_BGRA32 ||       PIXFMT == V4L2_PIX_FMT_XBGR444 || PIXFMT == V4L2_PIX_FMT_ABGR444\n"
"	vec4 cell = texture(tex, xy);\n"
"#if PIXFMT == V4L2_PIX_FMT_BGRA32 || PIXFMT == V4L2_PIX_FMT_ABGR444\n"
"	alpha = cell.r;\n"
"#endif\n"
"	rgb.rgb = cell.abg;\n"
"#elif PIXFMT == V4L2_PIX_FMT_GREY\n"
"	rgb.rgb = vec3(float(texture(tex, xy).r) / 255.0);\n"
"#elif PIXFMT == V4L2_PIX_FMT_Y10\n"
"	rgb.rgb = vec3(float(texture(tex, xy).r) / 1023.0);\n"
"#elif PIXFMT == V4L2_PIX_FMT_Y12\n"
"	rgb.rgb = vec3(float(texture(tex, xy).r) / 4095.0);\n"
"#elif PIXFMT == V4L2_PIX_FMT_Y16 || PIXFMT == V4L2_PIX_FMT_Z16\n"
"	rgb.rgb = vec3(float(texture(tex, xy).r) / 65535.0);\n"
"#elif PIXFMT == V4L2_PIX_FMT_Y16_BE\n"
"	uint low = texture(tex, xy).r >> 8;\n"
"	uint high = (texture(tex, xy).r & 0xFFu) << 8;\n"
"	rgb.rgb = vec3(float(high | low) / 65535.0);\n"
"#else\n"
"	vec4 color = texture(tex, xy);\n"
"\n"
"// RGB pixel formats with an alpha component\n"
"#if PIXFMT == V4L2_PIX_FMT_ARGB555 || PIXFMT == V4L2_PIX_FMT_ARGB555X ||     PIXFMT == V4L2_PIX_FMT_RGBA555 || PIXFMT == V4L2_PIX_FMT_ABGR555 ||     PIXFMT == V4L2_PIX_FMT_BGRA555\n"
"	alpha = color.a;\n"
"#endif\n"
"\n"
"#if PIXFMT == V4L2_PIX_FMT_BGR666\n"
"	vec3 frgb = floor(color.rgb * 255.0);\n"
"	frgb.r = floor(frgb.r / 64.0) + mod(frgb.g, 16.0) * 4.0;\n"
"	frgb.g = floor(frgb.g / 16.0) + mod(frgb.b, 4.0) * 16.0;\n"
"	frgb.b = floor(frgb.b / 4.0);\n"
"	rgb = frgb / 63.0;\n"
"#elif PIXFMT == V4L2_PIX_FMT_BGR24\n"
"	rgb = color.bgr;\n"
"#else\n"
"	rgb = color.rgb;\n"
"#endif\n"
"\n"
"#endif\n"
"\n"
"#if PIXFMT == V4L2_PIX_FMT_SBGGR8 || PIXFMT == V4L2_PIX_FMT_SGBRG8 ||     PIXFMT == V4L2_PIX_FMT_SGRBG8 || PIXFMT == V4L2_PIX_FMT_SRGGB8\n"
"	rgb = vec3(urgb) / 255.0;\n"
"#elif PIXFMT == V4L2_PIX_FMT_SBGGR10 || PIXFMT == V4L2_PIX_FMT_SGBRG10 ||       PIXFMT == V4L2_PIX_FMT_SGRBG10 || PIXFMT == V4L2_PIX_FMT_SRGGB10\n"
"	rgb = vec3(urgb) / 1023.0;\n"
"#elif PIXFMT == V4L2_PIX_FMT_SBGGR12 || PIXFMT == V4L2_PIX_FMT_SGBRG12 ||       PIXFMT == V4L2_PIX_FMT_SGRBG12 || PIXFMT == V4L2_PIX_FMT_SRGGB12\n"
"	rgb = vec3(urgb) / 4095.0;\n"
"#elif PIXFMT == V4L2_PIX_FMT_SBGGR16 || PIXFMT == V4L2_PIX_FMT_SGBRG16 ||       PIXFMT == V4L2_PIX_FMT_SGRBG16 || PIXFMT == V4L2_PIX_FMT_SRGGB16\n"
"	rgb = vec3(urgb) / 65535.0;\n"
"#endif\n"
"\n"
"#if QUANT == V4L2_QUANTIZATION_LIM_RANGE\n"
"	rgb -= 16.0 / 255.0;\n"
"	rgb *= 255.0 / 219.0;\n"
"#endif\n"
"\n"
"#else // IS_RGB\n"
"\n"
"#if PIXFMT == V4L2_PIX_FMT_YUYV\n"
"	vec4 luma_chroma = texture(tex, xeven ? xy : vec2(xy.x - texl_w, xy.y));\n"
"	yuv.r = xeven ? luma_chroma.r : luma_chroma.b;\n"
"	yuv.gb = luma_chroma.ga;\n"
"#elif PIXFMT == V4L2_PIX_FMT_YVYU\n"
"	vec4 luma_chroma = texture(tex, xeven ? xy : vec2(xy.x - texl_w, xy.y));\n"
"	yuv.r = xeven ? luma_chroma.r : luma_chroma.b;\n"
"	yuv.gb = luma_chroma.ag;\n"
"#elif PIXFMT == V4L2_PIX_FMT_UYVY\n"
"	vec4 luma_chroma = texture(tex, xeven ? xy : vec2(xy.x - texl_w, xy.y));\n"
"	yuv.r = xeven ? luma_chroma.g : luma_chroma.a;\n"
"	yuv.gb = luma_chroma.rb;\n"
"#elif PIXFMT == V4L2_PIX_FMT_VYUY\n"
"	vec4 luma_chroma = texture(tex, xeven ? xy : vec2(xy.x - texl_w, xy.y));\n"
"	yuv.r = xeven ? luma_chroma.g : luma_chroma.a;\n"
"	yuv.gb = luma_chroma.br;\n"
"#elif PIXFMT == V4L2_PIX_FMT_NV16 || PIXFMT == V4L2_PIX_FMT_NV16M ||       PIXFMT == V4L2_PIX_FMT_NV12 || PIXFMT == V4L2_PIX_FMT_NV12M\n"
"	yuv.r = texture(ytex, xy).r;\n"
"	if (xeven) {\n"
"		yuv.g = texture(uvtex, xy).r;\n"
"		yuv.b = texture(uvtex, vec2(xy.x + texl_w, xy.y)).r;\n"
"	} else {\n"
"		yuv.g = texture(uvtex, vec2(xy.x - texl_w, xy.y)).r;\n"
"		yuv.b = texture(uvtex, xy).r;\n"
"	}\n"
"#elif PIXFMT == V4L2_PIX_FMT_NV61 || PIXFMT == V4L2_PIX_FMT_NV61M ||       PIXFMT == V4L2_PIX_FMT_NV21 || PIXFMT == V4L2_PIX_FMT_NV21M\n"
"	yuv.r = texture(ytex, xy).r;\n"
"	if (xeven) {\n"
"		yuv.g = texture(uvtex, vec2(xy.x + texl_w, xy.y)).r;\n"
"		yuv.b = texture(uvtex, xy).r;\n"
"	} else {\n"
"		yuv.g = texture(uvtex, xy).r;\n"
"		yuv.b = texture(uvtex, vec2(xy.x - texl_w, xy.y)).r;\n"
"	}\n"
"#elif PIXFMT == V4L2_PIX_FMT_NV24\n"
"	yuv.r = texture(ytex, xy).r;\n"
"	yuv.g = texture(uvtex, xy).r;\n"
"	yuv.b = texture(uvtex, xy).g;\n"
"#elif PIXFMT == V4L2_PIX_FMT_NV42\n"
"	yuv.r = texture(ytex, xy).r;\n"
"	yuv.g = texture(uvtex, xy).g;\n"
"	yuv.b = texture(uvtex, xy).r;\n"
"#elif PIXFMT == V4L2_PIX_FMT_YUV555\n"
"	vec4 color = texture(tex, xy);\n"
"	alpha = color.a;\n"
"	yuv = color.rgb;\n"
"#elif PIXFMT == V4L2_PIX_FMT_YUV444 || PIXFMT == V4L2_PIX_FMT_YUV32 ||       PIXFMT == V4L2_PIX_FMT_XYUV32 || PIXFMT == V4L2_PIX_FMT_AYUV32\n"
"	vec4 color = texture(tex, xy);\n"
"#if PIXFMT == V4L2_PIX_FMT_AYUV32\n"
"	alpha = color.r;\n"
"#endif\n"
"	yuv.r = color.g;\n"
"	yuv.g = color.b;\n"
"	yuv.b = color.a;\n"
"#elif PIXFMT == V4L2_PIX_FMT_VUYA32 || PIXFMT == V4L2_PIX_FMT_VUYX32\n"
"	vec4 color = texture(tex, xy);\n"
"#if PIXFMT == V4L2_PIX_FMT_VUYA32\n"
"	alpha = color.a;\n"
"#endif\n"
"	yuv.r = color.b;\n"
"	yuv.g = color.g;\n"
"	yuv.b = color.r;\n"
"#elif PIXFMT == V4L2_PIX_FMT_YUV565\n"
"	yuv = texture(tex, xy).rgb;\n"
"#elif PIXFMT == V4L2_PIX_FMT_YUV422P || PIXFMT == V4L2_PIX_FMT_YUV420 || PIXFMT == V4L2_PIX_FMT_YVU420 ||       PIXFMT == V4L2_PIX_FMT_YUV420M || PIXFMT == V4L2_PIX_FMT_YVU420M ||       PIXFMT == V4L2_PIX_FMT_YUV422M || PIXFMT == V4L2_PIX_FMT_YVU422M ||       PIXFMT == V4L2_PIX_FMT_YUV444M || PIXFMT == V4L2_PIX_FMT_YVU444M\n"
"	yuv = vec3(texture(ytex, xy).r, texture(utex, xy).r, texture(vtex, xy).r);\n"
"#endif\n"
"\n"
"#if IS_HSV\n"
"	vec4 color = texture(tex, xy);\n"
"\n"
"#if PIXFMT == V4L2_PIX_FMT_HSV32\n"
"	color = color.gbar;\n"
"#endif\n"
"	// From http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n"
"	float hue = color.r;\n"
"\n"
"#if HSVENC == V4L2_HSV_ENC_180\n"
"	hue = (hue * 256.0) / 180.0;\n"
"#endif\n"
"	vec3 c = vec3(hue, color.g, color.b);\n"
"	vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n"
"	vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n"
"	rgb = c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n"
"#else // IS_HSV\n"
"	yuv.gb -= 0.5;\n"
"#endif\n"
"\n"
"#if QUANT != V4L2_QUANTIZATION_FULL_RANGE || YCBCRENC == V4L2_YCBCR_ENC_XV601 || YCBCRENC == V4L2_YCBCR_ENC_XV709\n"
"	/*\n"
"	 * xv709 and xv601 have full range quantization, but they still\n"
"	 * need to be normalized as if they were limited range. But the\n"
"	 * result are values outside the normal 0-1 range, which is the\n"
"	 * point of these extended gamut encodings.\n"
"	 */\n"
"	const vec3 scale = vec3(255.0 / 219.0, 255.0 / 224.0, 255.0 / 224.0);\n"
"	const vec3 offset = vec3(16.0 / 255.0, 0.0, 0.0);\n"
"\n"
"	yuv -= offset;\n"
"	yuv *= scale;\n"
"#endif\n"
"\n"
"#if YCBCRENC == V4L2_YCBCR_ENC_BT2020_CONST_LUM\n"
"	// BT.2020_CONST_LUM luma coefficients\n"
"	float y = yuv.r;\n"
"	float u = yuv.g;\n"
"	float v = yuv.b;\n"
"	float b = u <= 0.0 ? y + 1.9404 * u : y + 1.5816 * u;\n"
"	float r = v <= 0.0 ? y + 1.7184 * v : y + 0.9936 * v;\n"
"	float lin_r = (r < 0.081) ? r / 4.5 : pow((r + 0.099) / 1.099, 1.0 / 0.45);\n"
"	float lin_b = (b < 0.081) ? b / 4.5 : pow((b + 0.099) / 1.099, 1.0 / 0.45);\n"
"	float lin_y = (y < 0.081) ? y / 4.5 : pow((y + 0.099) / 1.099, 1.0 / 0.45);\n"
"	float lin_g = lin_y / 0.6780 - lin_r * 0.2627 / 0.6780 - lin_b * 0.0593 / 0.6780;\n"
"	float g = (lin_g < 0.018) ? lin_g * 4.5 : 1.099 * pow(lin_g, 0.45) - 0.099;\n"
"	rgb = vec3(r, g, b);\n"
"#elif !IS_HSV\n"
"	rgb = yuv2rgb * yuv;\n"
"#endif\n"
"#endif // !IS_RGB\n"
"\n"
"// Convert non-linear R'G'B' to linear RGB, taking into account the\n"
"// colorspace.\n"
"#if XFERFUNC == V4L2_XFER_FUNC_SMPTE240M\n"
"\n"
"// Old obsolete HDTV standard. Replaced by REC 709.\n"
"// This is the transfer function for SMPTE 240M\n"
"#define XFER(c) (((c) < 0.0913) ? (c) / 4.0 : pow(((c) + 0.1115) / 1.1115, 1.0 / 0.45))\n"
"\n"
"	rgb = vec3(XFER(rgb.r), XFER(rgb.g), XFER(rgb.b));\n"
"\n"
"#elif XFERFUNC == V4L2_XFER_FUNC_SRGB\n"
"\n"
"// This is used for sRGB as specified by the IEC FDIS 61966-2-1 standard\n"
"#define XFER(c) (((c) < -0.04045) ? -pow((-(c) + 0.055) / 1.055, 2.4) : 		(((c) <= 0.04045) ? (c) / 12.92 : pow(((c) + 0.055) / 1.055, 2.4)))\n"
"\n"
"	rgb = vec3(XFER(rgb.r), XFER(rgb.g), XFER(rgb.b));\n"
"\n"
"#elif XFERFUNC == V4L2_XFER_FUNC_OPRGB\n"
"\n"
"	// Avoid powers of negative numbers\n"
"	rgb = max(rgb, vec3(0.0));\n"
"	rgb = pow(rgb, vec3(2.19921875));\n"
"\n"
"#elif XFERFUNC == V4L2_XFER_FUNC_DCI_P3\n"
"\n"
"	// Avoid powers of negative numbers\n"
"	rgb = max(rgb, vec3(0.0));\n"
"	rgb = pow(rgb, vec3(2.6));\n"
"\n"
"#elif XFERFUNC == V4L2_XFER_FUNC_SMPTE2084\n"
"	const vec3 m1 = vec3(1.0 / ((2610.0 / 4096.0) / 4.0));\n"
"	const vec3 m2 = vec3(1.0 / (128.0 * 2523.0 / 4096.0));\n"
"	const vec3 c1 = vec3(3424.0 / 4096.0);\n"
"	const vec3 c2 = vec3(32.0 * 2413.0 / 4096.0);\n"
"	const vec3 c3 = vec3(32.0 * 2392.0 / 4096.0);\n"
"\n"
"	// Avoid powers of negative numbers\n"
"	rgb = max(rgb, vec3(0.0));\n"
"	rgb = pow(rgb, m2);\n"
"	// The factor 100 is because SMPTE-2084 maps to 0-10000 cd/m^2\n"
"	// whereas other transfer functions map to 0-100 cd/m^2.\n"
"	rgb = pow(max(rgb - c1, vec3(0.0)) / (c2 - rgb * c3), m1) * 100.0;\n"
"\n"
"#elif XFERFUNC != V4L2_XFER_FUNC_NONE\n"
"\n"
"// All others use the transfer function specified by REC 709\n"
"#define XFER(c) (((c) <= -0.081) ? -pow(((c) - 0.099) / -1.099, 1.0 / 0.45) : 		 (((c) < 0.081) ? (c) / 4.5 : pow(((c) + 0.099) / 1.099, 1.0 / 0.45)))\n"
"\n"
"	rgb = vec3(XFER(rgb.r), XFER(rgb.g), XFER(rgb.b));\n"
"\n"
"#endif\n"
"\n"
"// Convert the given colorspace to the REC 709/sRGB colorspace. All colors are\n"
"// specified as linear RGB.\n"
"#if COLSP == V4L2_COLORSPACE_SMPTE170M || COLSP == V4L2_COLORSPACE_SMPTE240M ||     COLSP == V4L2_COLORSPACE_470_SYSTEM_M || COLSP == V4L2_COLORSPACE_470_SYSTEM_BG ||     COLSP == V4L2_COLORSPACE_OPRGB || COLSP == V4L2_COLORSPACE_DCI_P3 ||     COLSP == V4L2_COLORSPACE_BT2020\n"
"	rgb = colconv * rgb;\n"
"#endif\n"
"\n"
"// Convert linear RGB to non-linear R'G'B', assuming an sRGB display colorspace.\n"
"\n"
"#define XFER_SRGB(c) (((c) < -0.0031308) ? -1.055 * pow(-(c), 1.0 / 2.4) + 0.055 : 	(((c) <= 0.0031308) ? (c) * 12.92 : 1.055 * pow(c, 1.0 / 2.4) - 0.055))\n"
"\n"
"	rgb = vec3(XFER_SRGB(rgb.r), XFER_SRGB(rgb.g), XFER_SRGB(rgb.b));\n"
"\n"
"	fs_FragColor = vec4(rgb, alpha);\n"
"}\n"
